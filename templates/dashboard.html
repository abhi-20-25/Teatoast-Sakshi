<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sakshi.AI - Dashboard</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root { --bg-primary: #0D1117; --bg-secondary: #161B22; --border-color: #30363D; --text-primary: #C9D1D9; --text-secondary: #8B949E; --accent-color: #238636; --accent-hover: #2ea043; }
        body { font-family: 'Inter', sans-serif; margin: 0; background-color: var(--bg-primary); color: var(--text-primary); }
        .glass-nav { background: rgba(13, 17, 23, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-bottom: 1px solid var(--border-color); }
        .header { padding: 15px 30px; display: flex; align-items: center; justify-content: space-between; }
        .header-logo { display: flex; align-items: center; gap: 12px; }
        .header h1 { margin: 0; font-size: 1.5em; font-weight: 700; color: #fff; }
        .container { padding: 20px; max-width: 1400px; margin: 0 auto; }
        .app-section { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 25px; }
        .app-header { padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; cursor: move; }
        .app-header h2 { margin: 0; font-size: 1.2em; }
        .app-header .status { font-size: 0.9em; color: var(--text-secondary); }
        .app-header .status .online-dot { display: inline-block; width: 8px; height: 8px; background-color: var(--accent-color); border-radius: 50%; margin-right: 6px; }
        .app-content { padding: 20px; }
        .btn { padding: 8px 16px; cursor: pointer; border: 1px solid var(--border-color); background-color: #21262d; color: var(--text-primary); border-radius: 6px; transition: background-color 0.2s; }
        .btn:hover { background-color: var(--border-color); }
        .btn-primary { background-color: var(--accent-color); border-color: var(--accent-color); color: #fff; text-decoration: none; }
        .btn-primary:hover { background-color: var(--accent-hover); border-color: var(--accent-hover); }
        .history-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 10px; min-height: 200px; }
        .history-item { border: 1px solid var(--border-color); border-radius: 5px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; background-color: var(--bg-primary); transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer; }
        .history-item:hover { transform: translateY(-4px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .history-item img { width: 100%; aspect-ratio: 4/3; object-fit: cover; background: #000; }
        .history-item-info { padding: 10px; font-size: 0.8em; }
        .history-item-info p { margin: 0 0 5px 0; color: var(--text-secondary); }
        .history-item-info strong { color: var(--text-primary); }
        .pagination { margin-top: 20px; text-align: center; }
        .pagination button { padding: 8px 16px; margin: 0 5px; cursor: pointer; border: 1px solid var(--border-color); background-color: #21262d; color: var(--text-primary); border-radius: 6px; }
        .pagination button:disabled { cursor: not-allowed; opacity: 0.5; }
        .layout-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .stream-box { border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; max-width: 100%; position: relative; }
        .stream-box img { width: 100%; display: block; background-color: #000; }
        .stream-header, .stream-footer { padding: 10px; background-color: var(--bg-primary); font-weight: bold; }
        .stream-header { font-size: 0.9em; text-align: left; }
        .stream-footer { font-size: 1.1em; text-align: center; }
        .report-section { flex-grow: 1; min-width: 300px; }
        .report-section input[type="date"] { background-color: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 5px; border-radius: 4px; }
        .report-section table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .report-section th, .report-section td { border: 1px solid var(--border-color); padding: 8px; text-align: left; font-size: 0.9em; }
        .report-section th { background-color: #21262d; }
        .tab-nav { display: flex; border-bottom: 1px solid var(--border-color); flex-wrap: wrap; }
        .tab-button { padding: 10px 15px; cursor: pointer; background: transparent; color: var(--text-secondary); border: none; border-bottom: 3px solid transparent; font-size: 0.9em; }
        .tab-button.active { border-bottom: 3px solid var(--accent-color); font-weight: bold; color: var(--text-primary); }
        .tab-content { display: none; padding-top: 15px; }
        .tab-content.active { display: block; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); }
        .modal-content { background-color: var(--bg-secondary); margin: 5% auto; padding: 25px; border: 1px solid var(--border-color); width: 90%; max-width: 900px; border-radius: 8px; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; margin-bottom: 20px; }
        .modal-header h2 { margin: 0; }
        .close-btn { color: var(--text-secondary); font-size: 28px; font-weight: bold; cursor: pointer; }
        .report-controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 20px; }
        .summary-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 25px; }
        .summary-card { background-color: var(--bg-primary); padding: 20px; border-radius: 6px; border: 1px solid var(--border-color); }
        .summary-card h4 { margin: 0 0 5px 0; color: var(--text-secondary); font-size: 0.9em; font-weight: 500; }
        .summary-card p { margin: 0; font-size: 1.5em; font-weight: 600; }
        .lightbox { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); justify-content: center; align-items: center; }
        .lightbox img { max-width: 90%; max-height: 90%; object-fit: contain; }
        .lightbox-close { position: absolute; top: 20px; right: 35px; color: #fff; font-size: 40px; font-weight: bold; cursor: pointer; transition: color 0.2s; }
        .lightbox-close:hover { color: var(--accent-color); }
        .filter-controls { display: flex; align-items: center; gap: 10px; margin-top: 15px; padding: 10px; background-color: var(--bg-primary); border-radius: 6px; }
        .roi-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; z-index: 10; pointer-events: none; }
        .roi-canvas.active { pointer-events: all; }
        .roi-controls { display: none; gap: 10px; align-items: center; margin-top: 10px; flex-wrap: wrap; background-color: var(--bg-primary); padding: 10px; border-radius: 6px; }
        .roi-controls.active { display: flex; }
        .roi-mode-indicator { font-size: 0.9em; padding: 5px 10px; border-radius: 4px; font-weight: 600; }
        .roi-mode-main { background-color: rgba(255, 255, 0, 0.2); color: #ffff00; border: 1px solid #ffff00; }
        .roi-mode-secondary { background-color: rgba(0, 255, 255, 0.2); color: #00ffff; border: 1px solid #00ffff; }
        .line-editor-controls { display: none; gap: 10px; align-items: center; margin-top: 10px; flex-wrap: wrap; background-color: var(--bg-primary); padding: 10px; border-radius: 6px; }
        .line-editor-controls.active { display: flex; }
        .btn-group { display: flex; gap: 5px; }
        .btn.selected { background-color: var(--accent-color); border-color: var(--accent-color); color: white; }
        .form-input { background-color: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; }
        .form-input:focus { outline: none; border-color: var(--accent-color); }
        .hidden { display: none !important; }
        @media (max-width: 768px) { .layout-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body class="antialiased">

<header class="glass-nav sticky top-0 z-50">
    <div class="header max-w-[1400px] mx-auto">
        <div class="header-logo">
            <svg style="width: 2rem; height: 2rem; color: var(--accent-color);" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 18.5C8.97 18.5 6.5 16.03 6.5 13H8.5C8.5 14.93 10.07 16.5 12 16.5C13.93 16.5 15.5 14.93 15.5 13C15.5 11.07 13.93 9.5 12 9.5C10.07 9.5 8.5 11.07 8.5 13H6.5C6.5 9.97 8.97 7.5 12 7.5C15.03 7.5 17.5 9.97 17.5 13C17.5 16.03 15.03 18.5 12 18.5Z" fill="currentColor"/></svg>
            <h1>Sakshi<span style="color: var(--accent-color);">.AI</span> Dashboard</h1>
        </div>
        <a href="/" style="color: var(--text-secondary); font-size: 0.9em; text-decoration: none;">&larr; Back to Landing Page</a>
    </div>
</header>

<div class="container" id="dashboard-container"></div>

<div id="reportModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="reportModalTitle">Footfall Analysis Report</h2>
            <span class="close-btn" onclick="closeReportModal()">&times;</span>
        </div>
        <div class="report-controls">
            <span>Period:</span>
            <button class="btn" onclick="generateReport('7days')">Last 7 Days</button>
            <button class="btn" onclick="generateReport('30days')">Last 30 Days</button>
            <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                <span>Chart Type:</span>
                <button class="btn" id="barChartBtn" onclick="renderChart('bar')">Bar</button>
                <button class="btn" id="lineChartBtn" onclick="renderChart('line')">Line</button>
            </div>
        </div>
        <div id="reportError" style="color: #f87171; margin-bottom: 15px;"></div>
        <div class="summary-cards">
            <div class="summary-card"><h4>Total Footfall</h4><p id="summaryTotal">--</p></div>
            <div class="summary-card"><h4>Busiest Day</h4><p id="summaryDay">--</p></div>
            <div class="summary-card"><h4>Peak Hour (Avg)</h4><p id="summaryHour">--</p></div>
        </div>
        <div><canvas id="reportChart"></canvas></div>
    </div>
</div>

<div id="shutterReportModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="shutterReportModalTitle">Shutter Status Report</h2>
            <span class="close-btn" onclick="closeShutterReportModal()">&times;</span>
        </div>
        <div class="report-controls">
            <label for="shutter-report-start">From:</label>
            <input type="date" id="shutter-report-start">
            <label for="shutter-report-end">To:</label>
            <input type="date" id="shutter-report-end">
            <button class="btn btn-primary" onclick="generateShutterReport()">Generate</button>
        </div>
        <div id="shutterReportError" style="color: #f87171; margin-bottom: 15px;"></div>
        <div class="report-section">
            <table id="shutterReportTable">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>First Open</th>
                        <th>First Close</th>
                    </tr>
                </thead>
                <tbody id="shutterReportTableBody">
                </tbody>
            </table>
        </div>
    </div>
</div>

<div id="shutterVideoModal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
            <h2 id="shutterVideoModalTitle">Shutter Event Video</h2>
            <span class="close-btn" onclick="closeShutterVideoModal()">&times;</span>
        </div>
        <div style="padding: 10px 0;">
            <video id="shutterVideoPlayer" width="100%" controls autoplay muted playsinline>
                Your browser does not support the video tag.
            </video>
        </div>
    </div>
</div>


<div id="lightbox" class="lightbox" onclick="closeLightbox()">
    <span class="lightbox-close">&times;</span>
    <img id="lightbox-img" src="">
</div>

<!-- ROI Editor Modal -->
<div id="roiEditorModal" class="modal">
    <div class="modal-content" style="max-width: 95%; max-height: 95vh; overflow-y: auto;">
        <div class="modal-header">
            <h2 id="roiModalTitle">Edit ROI - Queue Monitor</h2>
            <span class="close-btn" onclick="closeRoiModal()">&times;</span>
        </div>
        <div style="padding: 20px;">
            <!-- Video Preview with Canvas -->
            <div style="position: relative; display: inline-block; max-width: 100%; background: #000;">
                <img id="roiModalImage" src="" alt="Video Preview" 
                     style="max-width: 100%; height: auto; display: block;" crossorigin="anonymous">
                <canvas id="roiModalCanvas" 
                        style="position: absolute; top: 0; left: 0; cursor: crosshair;"
                        onmousedown="handleModalCanvasMouseDown(event)"
                        onmousemove="handleModalCanvasMouseMove(event)"
                        onmouseup="handleModalCanvasMouseUp(event)"
                        onclick="handleModalCanvasClick(event)"></canvas>
            </div>
            
            <!-- Controls -->
            <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; background: var(--bg-primary); padding: 15px; border-radius: 6px;">
                <span id="roiModeIndicator" class="roi-mode-indicator roi-mode-main">
                    Drawing: Queue Area (Yellow)
                </span>
                <div class="btn-group">
                    <button class="btn" onclick="switchModalRoiMode('main')">Draw Queue</button>
                    <button class="btn" onclick="switchModalRoiMode('secondary')">Draw Counter</button>
                </div>
                <button class="btn" onclick="resetModalRoi()">Reset Current</button>
                <button class="btn" onclick="clearAllModalRoi()">Clear All</button>
                <button class="btn" onclick="closeRoiModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveModalRoi()">Save ROI & Settings</button>
            </div>
            
            <!-- Instructions -->
            <div style="margin-top: 15px; padding: 12px; background-color: var(--bg-secondary); border-radius: 6px; border-left: 3px solid var(--accent-color);">
                <strong>📐 Instructions:</strong>
                <ul style="margin: 8px 0; padding-left: 25px; line-height: 1.6;">
                    <li><strong>Click 4 points</strong> to define each area</li>
                    <li><strong>Drag points</strong> to adjust position after placing</li>
                    <li><strong>Yellow area</strong> = Queue waiting zone</li>
                    <li><strong>Cyan area</strong> = Counter/Service area</li>
                    <li>Polygon <strong>auto-closes</strong> after 4 points</li>
                </ul>
            </div>
            
            <!-- Queue Configuration -->
            <div style="margin-top: 20px; padding: 20px; background-color: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <h3 style="margin-top: 0; color: var(--accent-color);">⚙️ Queue Detection Settings</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-top: 15px;">
                    <div>
                        <label style="font-weight: 600; display: block; margin-bottom: 8px;">Queue Alert Threshold:</label>
                        <input type="number" id="queueAlertThreshold" min="1" max="50" value="2" 
                               class="form-input" style="width: 100%; padding: 10px;"
                               onchange="updateThresholdDisplay()">
                        <small style="color: var(--text-secondary); display: block; margin-top: 5px;">
                            🚨 Alert when queue has <strong>this many or more</strong> people
                        </small>
                    </div>
                    <div>
                        <label style="font-weight: 600; display: block; margin-bottom: 8px;">Counter Threshold:</label>
                        <input type="number" id="counterThreshold" min="0" max="10" value="1" 
                               class="form-input" style="width: 100%; padding: 10px;"
                               onchange="updateThresholdDisplay()">
                        <small style="color: var(--text-secondary); display: block; margin-top: 5px;">
                            👤 Alert when counter has <strong>this many or fewer</strong> people
                        </small>
                    </div>
                    <div>
                        <label style="font-weight: 600; display: block; margin-bottom: 8px;">Dwell Time (seconds):</label>
                        <input type="number" id="queueDwellTime" min="1" max="60" value="3" step="0.5"
                               class="form-input" style="width: 100%; padding: 10px;">
                        <small style="color: var(--text-secondary); display: block; margin-top: 5px;">
                            ⏱️ Person must stay <strong>this long</strong> to be counted in queue
                        </small>
                    </div>
                    <div>
                        <label style="font-weight: 600; display: block; margin-bottom: 8px;">Alert Cooldown (seconds):</label>
                        <input type="number" id="queueAlertCooldown" min="30" max="600" value="180"
                               class="form-input" style="width: 100%; padding: 10px;">
                        <small style="color: var(--text-secondary); display: block; margin-top: 5px;">
                            🔔 Minimum <strong>time between alerts</strong> (prevents spam)
                        </small>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background-color: var(--bg-primary); border-radius: 6px; border-left: 3px solid #fbbf24;">
                    <strong style="color: #fbbf24;">⚡ Alert Logic:</strong>
                    <p style="margin: 10px 0 0 0; line-height: 1.6;">
                        Alert triggers when queue has <strong id="queueThresholdDisplay" style="color: var(--accent-color);">2+</strong> people 
                        AND counter has <strong id="counterThresholdDisplay" style="color: var(--accent-color);">≤1</strong> people.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- People Counter Line Editor Modal -->
<div id="lineEditorModal" class="modal">
    <div class="modal-content" style="max-width: 90%; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <h2 id="lineModalTitle">Edit Counting Line - People Counter</h2>
            <span class="close-btn" onclick="closeLineModal()">&times;</span>
        </div>
        <div style="padding: 20px;">
            <!-- Video Preview with Canvas -->
            <div style="position: relative; display: inline-block; max-width: 100%; background: #000;">
                <img id="lineModalImage" src="" alt="Video Preview" 
                     style="max-width: 100%; height: auto; display: block;" crossorigin="anonymous">
                <canvas id="lineModalCanvas" 
                        style="position: absolute; top: 0; left: 0; cursor: move;"
                        onmousedown="handleLineModalMouseDown(event)"
                        onmousemove="handleLineModalMouseMove(event)"
                        onmouseup="handleLineModalMouseUp(event)"></canvas>
            </div>
            
            <!-- Controls -->
            <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; background: var(--bg-primary); padding: 15px; border-radius: 6px;">
                <span style="font-weight: 600;">Line Orientation:</span>
                <div class="btn-group">
                    <button class="btn" onclick="setLineModalOrientation('vertical')">Vertical |</button>
                    <button class="btn" onclick="setLineModalOrientation('horizontal')">Horizontal —</button>
                    <button class="btn" onclick="setLineModalOrientation('angle')">Free Angle /</button>
                </div>
                <span style="font-size: 0.9em; color: var(--text-secondary); margin-left: auto;">Drag endpoints or line to adjust position</span>
                <button class="btn" onclick="closeLineModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveLineModal()">Save Line Position</button>
            </div>
            
            <!-- Instructions -->
            <div style="margin-top: 15px; padding: 12px; background-color: var(--bg-secondary); border-radius: 6px; border-left: 3px solid #10b981;">
                <strong>📏 Instructions:</strong>
                <ul style="margin: 8px 0; padding-left: 25px; line-height: 1.6;">
                    <li><strong>Choose orientation</strong> first (Vertical/Horizontal/Free Angle)</li>
                    <li><strong>Drag green circles</strong> at line ends to adjust position</li>
                    <li><strong>Drag the line itself</strong> to move it without changing angle</li>
                    <li><strong>Direction labels</strong> show which way is IN vs OUT</li>
                    <li>Left→Right crossing = <strong style="color: #10b981;">IN</strong>, Right→Left crossing = <strong style="color: #f59e0b;">OUT</strong></li>
                </ul>
            </div>
        </div>
    </div>
</div>

<script>
    const appConfigs = JSON.parse('{{ app_configs|tojson|safe }}');
    const dashboardContainer = document.getElementById('dashboard-container');
    const socket = io(`http://${window.location.hostname}:5001`);
    let reportChart = null;
    let activeReportChannel = null;
    let currentReportData = {};
    let queueCharts = {};
    let roiDrawingState = {};

    const reportModal = document.getElementById('reportModal');
    const shutterReportModal = document.getElementById('shutterReportModal');
    const shutterVideoModal = document.getElementById('shutterVideoModal');
    const shutterVideoPlayer = document.getElementById('shutterVideoPlayer');
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightbox-img');
    
    // --- Modal Controls ---
    function openLightbox(imgSrc) { lightboxImg.src = imgSrc; lightbox.style.display = 'flex'; }
    function closeLightbox() { lightbox.style.display = 'none'; }
    function openReportModal(channelId, channelName) {
        document.getElementById('reportModalTitle').textContent = `Footfall Report for ${channelName}`;
        activeReportChannel = channelId; reportModal.style.display = 'block'; generateReport('7days');
    }
    function closeReportModal() { reportModal.style.display = 'none'; if (reportChart) { reportChart.destroy(); reportChart = null; } }
    function openShutterReportModal(channelId, channelName) {
        document.getElementById('shutterReportModalTitle').textContent = `Shutter Report for ${channelName}`;
        activeReportChannel = channelId;
        const today = new Date().toISOString().split('T')[0];
        const sevenDaysAgo = new Date(Date.now() - 6 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        document.getElementById('shutter-report-start').value = sevenDaysAgo;
        document.getElementById('shutter-report-end').value = today;
        shutterReportModal.style.display = 'block';
        generateShutterReport();
    }
    function closeShutterReportModal() { shutterReportModal.style.display = 'none'; }
    function openShutterVideoModal(videoUrl, eventInfo) {
        if (!videoUrl || videoUrl === 'null') { alert("No video available for this event."); return; }
        document.getElementById('shutterVideoModalTitle').textContent = `Video for ${eventInfo}`;
        shutterVideoPlayer.src = videoUrl;
        shutterVideoModal.style.display = 'block';
        shutterVideoPlayer.play().catch(e => console.error("Video autoplay error:", e));
    }
    function closeShutterVideoModal() {
        shutterVideoModal.style.display = 'none';
        shutterVideoPlayer.pause();
        shutterVideoPlayer.src = '';
    }

    // --- Enhanced ROI Drawing with Draggable Points ---
    let dragState = null;
    
    // Open ROI Editor in Modal
    function startRoiEdit(appName, channelId) {
        openRoiModal(appName, channelId);
    }
    
    function cancelRoiEdit(appName, channelId) {
        const streamBox = document.getElementById(`stream-box-${appName}-${channelId}`);
        const canvas = streamBox.querySelector('.roi-canvas');
        canvas.style.display = 'none';
        canvas.classList.remove('active');
        streamBox.querySelector('.roi-controls').classList.remove('active');
        
        if (roiDrawingState[channelId] && roiDrawingState[channelId].resizeHandler) {
            window.removeEventListener('resize', roiDrawingState[channelId].resizeHandler);
        }
        
        delete roiDrawingState[channelId];
    }
    
    function resetRoi(appName, channelId) {
        if (roiDrawingState[channelId]) {
            roiDrawingState[channelId].points[roiDrawingState[channelId].currentPoly] = [];
            redrawRoiCanvas(appName, channelId);
        }
    }
    
    function clearAllRoi(appName, channelId) {
        if (roiDrawingState[channelId]) {
            roiDrawingState[channelId].points.main = [];
            roiDrawingState[channelId].points.secondary = [];
            redrawRoiCanvas(appName, channelId);
        }
    }
    
    function switchRoiMode(channelId, mode) {
        if (roiDrawingState[channelId]) {
            roiDrawingState[channelId].currentPoly = mode;
            updateModeIndicator(channelId);
            const appName = 'QueueMonitor';
            redrawRoiCanvas(appName, channelId);
        }
    }
    
    function updateModeIndicator(channelId) {
        const indicator = document.getElementById(`roi-mode-indicator-${channelId}`);
        if (!indicator || !roiDrawingState[channelId]) return;
        
        const mode = roiDrawingState[channelId].currentPoly;
        indicator.textContent = mode === 'main' ? 'Drawing: Queue Area (Yellow)' : 'Drawing: Counter Area (Cyan)';
        indicator.className = 'roi-mode-indicator ' + (mode === 'main' ? 'roi-mode-main' : 'roi-mode-secondary');
    }
    
    async function saveRoi(appName, channelId) {
        const state = roiDrawingState[channelId];
        if (!state) return;
        
        if (state.points.main.length < 3 && state.points.secondary.length < 3) {
            alert('Please draw at least one ROI area (minimum 3 points)');
            return;
        }
        
        const canvas = document.getElementById(`stream-box-${appName}-${channelId}`).querySelector('.roi-canvas');
        const normalizedPoints = {
            main: state.points.main.map(p => [p.x / canvas.width, p.y / canvas.height]),
            secondary: state.points.secondary.map(p => [p.x / canvas.width, p.y / canvas.height])
        };
        
        try {
            console.log('📤 Sending ROI data:', { app_name: appName, channel_id: channelId, roi_points: normalizedPoints });
            
            const response = await fetch('/api/set_roi', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ app_name: appName, channel_id: channelId, roi_points: normalizedPoints })
            });
            
            console.log('📥 Response status:', response.status, response.statusText);
            
            if (!response.ok) {
                throw new Error(`Server returned ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            console.log('📊 Response data:', result);
            
            if (result.success) {
                console.log('✅ SUCCESS: ROI saved');
                alert('✅ ROI saved successfully!');
                cancelRoiEdit(appName, channelId);
            } else {
                console.error('❌ ERROR:', result.error);
                alert(`❌ Error: ${result.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('❌ EXCEPTION:', error);
            alert(`❌ Failed to save ROI: ${error.message}\n\nPlease check:\n1. Server is running\n2. Network connection\n3. Browser console for details`);
        }
    }
    
    function handleCanvasClick(event, appName, channelId) {
        const state = roiDrawingState[channelId];
        if (!state) return;
        
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const clickedPoint = findNearestPoint(state, x, y, 10);
        if (clickedPoint) return;
        
        const currentPoints = state.points[state.currentPoly];
        if (currentPoints.length >= 4) {
            alert(`${state.currentPoly === 'main' ? 'Queue' : 'Counter'} area complete (4 points). Switch to other area or drag points to edit.`);
            return;
        }
        
        currentPoints.push({ x, y });
        redrawRoiCanvas(appName, channelId);
        
        if (currentPoints.length === 4) {
            if (state.currentPoly === 'main' && state.points.secondary.length < 4) {
                setTimeout(() => {
                    switchRoiMode(channelId, 'secondary');
                    alert('Queue area complete! Now draw Counter area (cyan)');
                }, 500);
            }
        }
    }
    
    function handleCanvasMouseDown(event, appName, channelId) {
        const state = roiDrawingState[channelId];
        if (!state) return;
        
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const clickedPoint = findNearestPoint(state, x, y, 10);
        if (clickedPoint) {
            dragState = { channelId, appName, poly: clickedPoint.poly, index: clickedPoint.index, canvas };
            canvas.style.cursor = 'move';
        }
    }
    
    function handleCanvasMouseMove(event, appName, channelId) {
        const state = roiDrawingState[channelId];
        if (!state) return;
        
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        if (!dragState) {
            const nearPoint = findNearestPoint(state, x, y, 10);
            canvas.style.cursor = nearPoint ? 'move' : 'crosshair';
        }
        
        if (dragState && dragState.channelId === channelId) {
            const points = state.points[dragState.poly];
            points[dragState.index] = { x, y };
            redrawRoiCanvas(appName, channelId);
        }
    }
    
    function handleCanvasMouseUp(event, appName, channelId) {
        if (dragState && dragState.channelId === channelId) {
            dragState.canvas.style.cursor = 'crosshair';
            dragState = null;
        }
    }
    
    function findNearestPoint(state, x, y, threshold) {
        for (const polyType of ['main', 'secondary']) {
            const points = state.points[polyType];
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const dist = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);
                if (dist <= threshold) return { poly: polyType, index: i };
            }
        }
        return null;
    }
    
    function redrawRoiCanvas(appName, channelId) {
        const state = roiDrawingState[channelId];
        if (!state) return;
        
        const canvas = document.getElementById(`stream-box-${appName}-${channelId}`).querySelector('.roi-canvas');
        const ctx = canvas.getContext('2d');
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawPolygon(ctx, state.points.main, 'rgba(255, 255, 0, 0.9)', 'rgba(255, 255, 0, 0.15)', state.currentPoly === 'main');
        drawPolygon(ctx, state.points.secondary, 'rgba(0, 255, 255, 0.9)', 'rgba(0, 255, 255, 0.15)', state.currentPoly === 'secondary');
    }
    
    function drawPolygon(ctx, points, strokeColor, fillColor, isActive) {
        if (points.length === 0) return;
        
        if (points.length > 1) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            if (points.length >= 4) {
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
            }
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = isActive ? 3 : 2;
            ctx.stroke();
        }
        
        points.forEach((p, idx) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, isActive ? 6 : 5, 0, 2 * Math.PI);
            ctx.fillStyle = strokeColor;
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(idx + 1, p.x, p.y);
        });
    }

    // --- People Counter Line Editor ---
    let lineEditorState = {};
    
    // Open Line Editor in Modal
    function startLineEdit(appName, channelId) {
        openLineModal(appName, channelId);
    }
    
    function startLineEditOld(appName, channelId) {
        const streamBox = document.getElementById(`stream-box-${appName}-${channelId}`);
        const canvas = streamBox.querySelector('.line-canvas');
        const img = streamBox.querySelector('img');
        const controls = streamBox.querySelector('.line-editor-controls');
        
        const resizeCanvas = () => {
            const rect = img.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        };
        
        resizeCanvas();
        const resizeHandler = () => { if (lineEditorState[channelId]) resizeCanvas(); };
        window.addEventListener('resize', resizeHandler);
        
        canvas.style.display = 'block';
        canvas.classList.add('active');
        controls.classList.add('active');
        
        lineEditorState[channelId] = {
            line: { start: { x: canvas.width / 2, y: 0 }, end: { x: canvas.width / 2, y: canvas.height } },
            orientation: 'vertical',
            dragPoint: null,
            resizeHandler: resizeHandler
        };
        
        redrawLineCanvas(appName, channelId);
    }
    
    function cancelLineEdit(appName, channelId) {
        const streamBox = document.getElementById(`stream-box-${appName}-${channelId}`);
        const canvas = streamBox.querySelector('.line-canvas');
        canvas.style.display = 'none';
        canvas.classList.remove('active');
        streamBox.querySelector('.line-editor-controls').classList.remove('active');
        
        if (lineEditorState[channelId] && lineEditorState[channelId].resizeHandler) {
            window.removeEventListener('resize', lineEditorState[channelId].resizeHandler);
        }
        
        delete lineEditorState[channelId];
    }
    
    function setLineOrientation(channelId, orientation) {
        const state = lineEditorState[channelId];
        if (!state) return;
        
        const canvas = document.querySelector(`#stream-box-PeopleCounter-${channelId} .line-canvas`);
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        state.orientation = orientation;
        
        if (orientation === 'vertical') {
            state.line.start = { x: centerX, y: 0 };
            state.line.end = { x: centerX, y: canvas.height };
        } else if (orientation === 'horizontal') {
            state.line.start = { x: 0, y: centerY };
            state.line.end = { x: canvas.width, y: centerY };
        }
        
        redrawLineCanvas('PeopleCounter', channelId);
    }
    
    function handleLineCanvasMouseDown(event, appName, channelId) {
        const state = lineEditorState[channelId];
        if (!state) return;
        
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const distStart = Math.sqrt((x - state.line.start.x) ** 2 + (y - state.line.start.y) ** 2);
        const distEnd = Math.sqrt((x - state.line.end.x) ** 2 + (y - state.line.end.y) ** 2);
        
        if (distStart < 15) {
            state.dragPoint = 'start';
        } else if (distEnd < 15) {
            state.dragPoint = 'end';
        } else {
            const distToLine = pointToLineDistance(x, y, state.line.start, state.line.end);
            if (distToLine < 15) {
                state.dragPoint = 'line';
                state.dragOffset = { x: x - state.line.start.x, y: y - state.line.start.y };
            }
        }
    }
    
    function handleLineCanvasMouseMove(event, appName, channelId) {
        const state = lineEditorState[channelId];
        if (!state) return;
        
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        if (state.dragPoint === 'start') {
            state.line.start = { x, y };
            redrawLineCanvas(appName, channelId);
        } else if (state.dragPoint === 'end') {
            state.line.end = { x, y };
            redrawLineCanvas(appName, channelId);
        } else if (state.dragPoint === 'line') {
            const dx = x - state.dragOffset.x - state.line.start.x;
            const dy = y - state.dragOffset.y - state.line.start.y;
            state.line.start.x += dx;
            state.line.start.y += dy;
            state.line.end.x += dx;
            state.line.end.y += dy;
            redrawLineCanvas(appName, channelId);
        }
    }
    
    function handleLineCanvasMouseUp(event, appName, channelId) {
        const state = lineEditorState[channelId];
        if (state) state.dragPoint = null;
    }
    
    function pointToLineDistance(px, py, lineStart, lineEnd) {
        const dx = lineEnd.x - lineStart.x;
        const dy = lineEnd.y - lineStart.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length === 0) return Math.sqrt((px - lineStart.x) ** 2 + (py - lineStart.y) ** 2);
        
        const t = Math.max(0, Math.min(1, ((px - lineStart.x) * dx + (py - lineStart.y) * dy) / (length * length)));
        const projX = lineStart.x + t * dx;
        const projY = lineStart.y + t * dy;
        
        return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
    }
    
    function redrawLineCanvas(appName, channelId) {
        const state = lineEditorState[channelId];
        if (!state) return;
        
        const canvas = document.querySelector(`#stream-box-${appName}-${channelId} .line-canvas`);
        const ctx = canvas.getContext('2d');
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.beginPath();
        ctx.moveTo(state.line.start.x, state.line.start.y);
        ctx.lineTo(state.line.end.x, state.line.end.y);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.9)';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        [state.line.start, state.line.end].forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        });
        
        const midX = (state.line.start.x + state.line.end.x) / 2;
        const midY = (state.line.start.y + state.line.end.y) / 2;
        
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.textAlign = 'center';
        
        if (state.orientation === 'vertical') {
            ctx.strokeText('IN →', state.line.start.x + 50, 30);
            ctx.fillText('IN →', state.line.start.x + 50, 30);
            ctx.strokeText('← OUT', state.line.start.x - 50, 30);
            ctx.fillText('← OUT', state.line.start.x - 50, 30);
        } else {
            ctx.strokeText('↑ OUT', midX, midY - 20);
            ctx.fillText('↑ OUT', midX, midY - 20);
            ctx.strokeText('IN ↓', midX, midY + 30);
            ctx.fillText('IN ↓', midX, midY + 30);
        }
    }
    
    async function saveLinePosition(appName, channelId) {
        const state = lineEditorState[channelId];
        if (!state) return;
        
        const canvas = document.querySelector(`#stream-box-${appName}-${channelId} .line-canvas`);
        
        const normalizedLine = {
            start: { x: state.line.start.x / canvas.width, y: state.line.start.y / canvas.height },
            end: { x: state.line.end.x / canvas.width, y: state.line.end.y / canvas.height },
            orientation: state.orientation
        };
        
        const response = await fetch('/api/set_counting_line', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ app_name: appName, channel_id: channelId, line_config: normalizedLine })
        });
        
        const result = await response.json();
        alert(result.success ? 'Counting line saved successfully!' : `Error: ${result.error}`);
        if(result.success) cancelLineEdit(appName, channelId);
    }

    // --- Modal ROI Editor Functions ---
    let modalRoiState = {
        appName: null,
        channelId: null,
        points: { main: [], secondary: [] },
        currentPoly: 'main',
        dragState: null
    };

    function openRoiModal(appName, channelId) {
        const modal = document.getElementById('roiEditorModal');
        const modalImage = document.getElementById('roiModalImage');
        const canvas = document.getElementById('roiModalCanvas');
        
        modalImage.src = `/video_feed/${appName}/${channelId}?t=${Date.now()}`;
        
        modalRoiState.appName = appName;
        modalRoiState.channelId = channelId;
        modalRoiState.points = { main: [], secondary: [] };
        modalRoiState.currentPoly = 'main';
        modalRoiState.dragState = null;
        
        loadExistingRoi(appName, channelId);
        loadQueueSettings(channelId);
        
        modalImage.onload = function() {
            canvas.width = modalImage.clientWidth;
            canvas.height = modalImage.clientHeight;
            canvas.style.width = modalImage.clientWidth + 'px';
            canvas.style.height = modalImage.clientHeight + 'px';
            redrawModalCanvas();
        };
        
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        
        updateModalModeIndicator();
    }

    function closeRoiModal() {
        document.getElementById('roiEditorModal').style.display = 'none';
        modalRoiState = { appName: null, channelId: null, points: { main: [], secondary: [] }, currentPoly: 'main', dragState: null };
    }

    async function loadExistingRoi(appName, channelId) {
        try {
            const response = await fetch(`/api/get_roi?app_name=${appName}&channel_id=${channelId}`);
            if (response.ok) {
                const data = await response.json();
                if (data.roi_points) {
                    const canvas = document.getElementById('roiModalCanvas');
                    setTimeout(() => {
                        if (data.roi_points.main && canvas.width > 0) {
                            modalRoiState.points.main = data.roi_points.main.map(p => ({
                                x: p[0] * canvas.width,
                                y: p[1] * canvas.height
                            }));
                        }
                        if (data.roi_points.secondary && canvas.width > 0) {
                            modalRoiState.points.secondary = data.roi_points.secondary.map(p => ({
                                x: p[0] * canvas.width,
                                y: p[1] * canvas.height
                            }));
                        }
                        redrawModalCanvas();
                    }, 200);
                }
            }
        } catch (error) {
            console.error('Error loading ROI:', error);
        }
    }

    async function loadQueueSettings(channelId) {
        try {
            const response = await fetch(`/api/get_queue_settings?channel_id=${channelId}`);
            if (response.ok) {
                const data = await response.json();
                document.getElementById('queueAlertThreshold').value = data.queue_threshold || 2;
                document.getElementById('counterThreshold').value = data.counter_threshold || 1;
                document.getElementById('queueDwellTime').value = data.dwell_time || 3;
                document.getElementById('queueAlertCooldown').value = data.alert_cooldown || 180;
                updateThresholdDisplay();
            }
        } catch (error) {
            console.error('Error loading queue settings:', error);
        }
    }

    function updateThresholdDisplay() {
        const queueThreshold = document.getElementById('queueAlertThreshold').value;
        const counterThreshold = document.getElementById('counterThreshold').value;
        document.getElementById('queueThresholdDisplay').textContent = queueThreshold + '+';
        document.getElementById('counterThresholdDisplay').textContent = '≤' + counterThreshold;
    }

    function switchModalRoiMode(mode) {
        modalRoiState.currentPoly = mode;
        updateModalModeIndicator();
        redrawModalCanvas();
    }

    function updateModalModeIndicator() {
        const indicator = document.getElementById('roiModeIndicator');
        if (modalRoiState.currentPoly === 'main') {
            indicator.textContent = 'Drawing: Queue Area (Yellow)';
            indicator.className = 'roi-mode-indicator roi-mode-main';
        } else {
            indicator.textContent = 'Drawing: Counter Area (Cyan)';
            indicator.className = 'roi-mode-indicator roi-mode-secondary';
        }
    }

    function resetModalRoi() {
        modalRoiState.points[modalRoiState.currentPoly] = [];
        redrawModalCanvas();
    }

    function clearAllModalRoi() {
        modalRoiState.points.main = [];
        modalRoiState.points.secondary = [];
        redrawModalCanvas();
    }

    function handleModalCanvasClick(event) {
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const clickedPoint = findNearestModalPoint(x, y, 10);
        if (clickedPoint) return;
        
        const currentPoints = modalRoiState.points[modalRoiState.currentPoly];
        if (currentPoints.length >= 4) {
            alert(`${modalRoiState.currentPoly === 'main' ? 'Queue' : 'Counter'} area complete (4 points). Switch to other area or drag points to edit.`);
            return;
        }
        
        currentPoints.push({ x, y });
        redrawModalCanvas();
        
        if (currentPoints.length === 4 && modalRoiState.currentPoly === 'main' && modalRoiState.points.secondary.length < 4) {
            setTimeout(() => {
                switchModalRoiMode('secondary');
                alert('Queue area complete! Now draw Counter area (cyan)');
            }, 500);
        }
    }

    function handleModalCanvasMouseDown(event) {
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const clickedPoint = findNearestModalPoint(x, y, 10);
        if (clickedPoint) {
            modalRoiState.dragState = { poly: clickedPoint.poly, index: clickedPoint.index };
            canvas.style.cursor = 'move';
        }
    }

    function handleModalCanvasMouseMove(event) {
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        if (!modalRoiState.dragState) {
            const nearPoint = findNearestModalPoint(x, y, 10);
            canvas.style.cursor = nearPoint ? 'move' : 'crosshair';
        } else {
            const points = modalRoiState.points[modalRoiState.dragState.poly];
            points[modalRoiState.dragState.index] = { x, y };
            redrawModalCanvas();
        }
    }

    function handleModalCanvasMouseUp(event) {
        if (modalRoiState.dragState) {
            event.target.style.cursor = 'crosshair';
            modalRoiState.dragState = null;
        }
    }

    function findNearestModalPoint(x, y, threshold) {
        for (const polyType of ['main', 'secondary']) {
            const points = modalRoiState.points[polyType];
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const dist = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);
                if (dist <= threshold) return { poly: polyType, index: i };
            }
        }
        return null;
    }

    function redrawModalCanvas() {
        const canvas = document.getElementById('roiModalCanvas');
        const ctx = canvas.getContext('2d');
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawModalPolygon(ctx, modalRoiState.points.main, 'rgba(255, 255, 0, 0.9)', 'rgba(255, 255, 0, 0.15)', modalRoiState.currentPoly === 'main');
        drawModalPolygon(ctx, modalRoiState.points.secondary, 'rgba(0, 255, 255, 0.9)', 'rgba(0, 255, 255, 0.15)', modalRoiState.currentPoly === 'secondary');
    }

    function drawModalPolygon(ctx, points, strokeColor, fillColor, isActive) {
        if (points.length === 0) return;
        
        if (points.length > 1) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            if (points.length >= 4) {
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
            }
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = isActive ? 3 : 2;
            ctx.stroke();
        }
        
        points.forEach((p, idx) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, isActive ? 6 : 5, 0, 2 * Math.PI);
            ctx.fillStyle = strokeColor;
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(idx + 1, p.x, p.y);
        });
    }

    async function saveModalRoi() {
        const canvas = document.getElementById('roiModalCanvas');
        
        if (modalRoiState.points.main.length < 3 && modalRoiState.points.secondary.length < 3) {
            alert('Please draw at least one ROI area (minimum 3 points)');
            return;
        }
        
        const normalizedPoints = {
            main: modalRoiState.points.main.map(p => [p.x / canvas.width, p.y / canvas.height]),
            secondary: modalRoiState.points.secondary.map(p => [p.x / canvas.width, p.y / canvas.height])
        };
        
        const queueSettings = {
            queue_threshold: parseInt(document.getElementById('queueAlertThreshold').value),
            counter_threshold: parseInt(document.getElementById('counterThreshold').value),
            dwell_time: parseFloat(document.getElementById('queueDwellTime').value),
            alert_cooldown: parseInt(document.getElementById('queueAlertCooldown').value)
        };
        
        try {
            console.log('📤 Sending ROI data to server:', {
                app_name: modalRoiState.appName,
                channel_id: modalRoiState.channelId,
                roi_points: normalizedPoints,
                queue_settings: queueSettings
            });
            
            const response = await fetch('/api/set_roi', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    app_name: modalRoiState.appName,
                    channel_id: modalRoiState.channelId,
                    roi_points: normalizedPoints,
                    queue_settings: queueSettings
                })
            });
            
            console.log('📥 Server response status:', response.status, response.statusText);
            
            if (!response.ok) {
                throw new Error(`Server returned ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            console.log('📊 Server response data:', result);
            
            if (result.success) {
                console.log('✅ SUCCESS: ROI and settings saved to database');
                alert('✅ ROI and settings saved successfully! Changes will take effect immediately.');
                closeRoiModal();
            } else {
                console.error('❌ ERROR: Server returned error:', result.error);
                alert(`❌ Error saving ROI: ${result.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('❌ EXCEPTION: Failed to save ROI:', error);
            alert(`❌ Failed to save ROI: ${error.message}\n\nPlease check:\n1. Server is running\n2. Network connection\n3. Browser console for details`);
        }
    }

    // --- Modal Line Editor Functions ---
    let modalLineState = {
        appName: null,
        channelId: null,
        line: { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } },
        orientation: 'vertical',
        dragPoint: null
    };

    function openLineModal(appName, channelId) {
        const modal = document.getElementById('lineEditorModal');
        const modalImage = document.getElementById('lineModalImage');
        const canvas = document.getElementById('lineModalCanvas');
        
        modalImage.src = `/video_feed/${appName}/${channelId}?t=${Date.now()}`;
        
        modalLineState.appName = appName;
        modalLineState.channelId = channelId;
        modalLineState.orientation = 'vertical';
        modalLineState.dragPoint = null;
        
        modalImage.onload = function() {
            canvas.width = modalImage.clientWidth;
            canvas.height = modalImage.clientHeight;
            canvas.style.width = modalImage.clientWidth + 'px';
            canvas.style.height = modalImage.clientHeight + 'px';
            
            modalLineState.line = {
                start: { x: canvas.width / 2, y: 0 },
                end: { x: canvas.width / 2, y: canvas.height }
            };
            
            loadExistingLine(appName, channelId);
            redrawLineModalCanvas();
        };
        
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
    }

    function closeLineModal() {
        document.getElementById('lineEditorModal').style.display = 'none';
        modalLineState = { appName: null, channelId: null, line: { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, orientation: 'vertical', dragPoint: null };
    }

    async function loadExistingLine(appName, channelId) {
        try {
            const response = await fetch(`/api/get_counting_line?channel_id=${channelId}`);
            if (response.ok) {
                const data = await response.json();
                if (data.line_config) {
                    const canvas = document.getElementById('lineModalCanvas');
                    setTimeout(() => {
                        if (canvas.width > 0) {
                            modalLineState.line = {
                                start: {
                                    x: data.line_config.start.x * canvas.width,
                                    y: data.line_config.start.y * canvas.height
                                },
                                end: {
                                    x: data.line_config.end.x * canvas.width,
                                    y: data.line_config.end.y * canvas.height
                                }
                            };
                            modalLineState.orientation = data.line_config.orientation || 'vertical';
                            redrawLineModalCanvas();
                        }
                    }, 200);
                }
            }
        } catch (error) {
            console.error('Error loading line config:', error);
        }
    }

    function setLineModalOrientation(orientation) {
        const canvas = document.getElementById('lineModalCanvas');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        modalLineState.orientation = orientation;
        
        if (orientation === 'vertical') {
            modalLineState.line = {
                start: { x: centerX, y: 0 },
                end: { x: centerX, y: canvas.height }
            };
        } else if (orientation === 'horizontal') {
            modalLineState.line = {
                start: { x: 0, y: centerY },
                end: { x: canvas.width, y: centerY }
            };
        }
        
        redrawLineModalCanvas();
    }

    function handleLineModalMouseDown(event) {
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const distStart = Math.sqrt((x - modalLineState.line.start.x) ** 2 + (y - modalLineState.line.start.y) ** 2);
        const distEnd = Math.sqrt((x - modalLineState.line.end.x) ** 2 + (y - modalLineState.line.end.y) ** 2);
        
        if (distStart < 15) {
            modalLineState.dragPoint = 'start';
            canvas.style.cursor = 'move';
        } else if (distEnd < 15) {
            modalLineState.dragPoint = 'end';
            canvas.style.cursor = 'move';
        } else {
            const distToLine = pointToLineDistance(x, y, modalLineState.line.start, modalLineState.line.end);
            if (distToLine < 15) {
                modalLineState.dragPoint = 'line';
                modalLineState.dragOffset = {
                    x: x - modalLineState.line.start.x,
                    y: y - modalLineState.line.start.y
                };
                canvas.style.cursor = 'move';
            }
        }
    }

    function handleLineModalMouseMove(event) {
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        if (modalLineState.dragPoint === 'start') {
            modalLineState.line.start = { x, y };
            redrawLineModalCanvas();
        } else if (modalLineState.dragPoint === 'end') {
            modalLineState.line.end = { x, y };
            redrawLineModalCanvas();
        } else if (modalLineState.dragPoint === 'line') {
            const dx = x - modalLineState.dragOffset.x - modalLineState.line.start.x;
            const dy = y - modalLineState.dragOffset.y - modalLineState.line.start.y;
            modalLineState.line.start.x += dx;
            modalLineState.line.start.y += dy;
            modalLineState.line.end.x += dx;
            modalLineState.line.end.y += dy;
            redrawLineModalCanvas();
        }
    }

    function handleLineModalMouseUp(event) {
        if (modalLineState.dragPoint) {
            event.target.style.cursor = 'move';
            modalLineState.dragPoint = null;
        }
    }

    function redrawLineModalCanvas() {
        const canvas = document.getElementById('lineModalCanvas');
        const ctx = canvas.getContext('2d');
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.beginPath();
        ctx.moveTo(modalLineState.line.start.x, modalLineState.line.start.y);
        ctx.lineTo(modalLineState.line.end.x, modalLineState.line.end.y);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.9)';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        [modalLineState.line.start, modalLineState.line.end].forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        });
        
        const midX = (modalLineState.line.start.x + modalLineState.line.end.x) / 2;
        const midY = (modalLineState.line.start.y + modalLineState.line.end.y) / 2;
        
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.textAlign = 'center';
        
        if (modalLineState.orientation === 'vertical') {
            ctx.strokeText('IN →', modalLineState.line.start.x + 50, 30);
            ctx.fillText('IN →', modalLineState.line.start.x + 50, 30);
            ctx.strokeText('← OUT', modalLineState.line.start.x - 50, 30);
            ctx.fillText('← OUT', modalLineState.line.start.x - 50, 30);
        } else {
            ctx.strokeText('↑ OUT', midX, midY - 20);
            ctx.fillText('↑ OUT', midX, midY - 20);
            ctx.strokeText('IN ↓', midX, midY + 30);
            ctx.fillText('IN ↓', midX, midY + 30);
        }
    }

    async function saveLineModal() {
        const canvas = document.getElementById('lineModalCanvas');
        
        const normalizedLine = {
            start: {
                x: modalLineState.line.start.x / canvas.width,
                y: modalLineState.line.start.y / canvas.height
            },
            end: {
                x: modalLineState.line.end.x / canvas.width,
                y: modalLineState.line.end.y / canvas.height
            },
            orientation: modalLineState.orientation
        };
        
        const response = await fetch('/api/set_counting_line', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_name: modalLineState.appName,
                channel_id: modalLineState.channelId,
                line_config: normalizedLine
            })
        });
        
        const result = await response.json();
        alert(result.success ? 'Counting line saved successfully! Changes will take effect immediately.' : `Error: ${result.error}`);
        if (result.success) closeLineModal();
    }

    // --- Report Generation ---
    async function generateReport(period) {
        if (!activeReportChannel) return;
        const errorEl = document.getElementById('reportError'); errorEl.textContent = 'Loading...';
        const response = await fetch(`/generate_report/${activeReportChannel}?period=${period}`);
        const data = await response.json();
        if (data.error) { errorEl.textContent = data.error; return; }
        errorEl.textContent = ''; currentReportData = data;
        document.getElementById('summaryTotal').textContent = data.summary.total_footfall;
        document.getElementById('summaryDay').textContent = data.summary.busiest_day;
        document.getElementById('summaryHour').textContent = data.summary.peak_hour;
        renderChart('bar');
    }
    function renderChart(type) {
        if (!currentReportData.labels) return;
        const ctx = document.getElementById('reportChart').getContext('2d');
        if (reportChart) reportChart.destroy();
        reportChart = new Chart(ctx, { type: type, data: { labels: currentReportData.labels, datasets: [{ label: 'Total Visitors', data: currentReportData.data, backgroundColor: 'rgba(35, 134, 54, 0.5)', borderColor: 'rgba(46, 160, 67, 1)', tension: 0.1 }] }, options: { scales: { y: { beginAtZero: true, grid: { color: 'rgba(201, 209, 217, 0.1)' }, ticks: { color: 'var(--text-secondary)'} }, x: { grid: { color: 'rgba(201, 209, 217, 0.1)' }, ticks: { color: 'var(--text-secondary)'} } }, plugins: { legend: { labels: { color: 'var(--text-primary)' } } } } });
    }
    async function fetchHistory(appName, page = 1, channelId = null, startDate = null, endDate = null) {
        const grid = document.getElementById(`grid-${appName}-${channelId}`);
        const pagination = document.getElementById(`pagination-${appName}-${channelId}`);
        if (!grid) return;
        let url = `/history/${appName}?page=${page}&limit=10&channel_id=${channelId}`;
        if (startDate && endDate) url += `&start_date=${startDate}&end_date=${endDate}`;
        grid.innerHTML = '<p>Loading history...</p>';
        const response = await fetch(url);
        const data = await response.json();
        grid.innerHTML = data.detections.length === 0 ? '<p>No detections found.</p>' : '';
        data.detections.forEach(d => {
            const item = document.createElement('div');
            item.className = 'history-item';
            item.innerHTML = `<img src="${d.media_url}" alt="Detection" loading="lazy" onclick="openLightbox('${d.media_url}')"><div class="history-item-info"><p><strong>Message:</strong> ${d.message}</p><p><strong>Time:</strong> ${d.timestamp}</p></div>`;
            grid.appendChild(item);
        });
        if (pagination) {
            pagination.innerHTML = '';
            const totalPages = Math.ceil(data.total / data.limit);
            if (totalPages > 1) {
                const prev = document.createElement('button'); prev.textContent = '<'; prev.disabled = data.page === 1;
                prev.onclick = () => fetchHistory(appName, data.page - 1, channelId, startDate, endDate);
                const next = document.createElement('button'); next.textContent = '>'; next.disabled = data.page >= totalPages;
                next.onclick = () => fetchHistory(appName, data.page + 1, channelId, startDate, endDate);
                pagination.append(prev, ` Page ${data.page} of ${totalPages} `, next);
            }
        }
    }
    function applyDateFilter(appName, channelId) {
        const startDate = document.getElementById(`start-date-${appName}-${channelId}`).value;
        const endDate = document.getElementById(`end-date-${appName}-${channelId}`).value;
        fetchHistory(appName, 1, channelId, startDate, endDate);
    }
    async function fetchPCReport(channelId, date) {
        const tableBody = document.getElementById(`pc-report-table-${channelId}`);
        if (!tableBody) return;
        tableBody.innerHTML = '<tr><td colspan="3">Loading...</td></tr>';
        const response = await fetch(`/report/${channelId}/${date}`);
        const data = await response.json();
        tableBody.innerHTML = '';
        Object.entries(data.hourly_data).forEach(([hour, counts]) => {
            const hourFormatted = new Date(0,0,0,hour).toLocaleTimeString('en-US', {hour: 'numeric', hour12: true});
            tableBody.innerHTML += `<tr><td>${hourFormatted}</td><td>${counts.in}</td><td>${counts.out}</td></tr>`;
        });
    }
    async function generateShutterReport() {
        if (!activeReportChannel) return;
        const startDate = document.getElementById('shutter-report-start').value;
        const endDate = document.getElementById('shutter-report-end').value;
        const errorEl = document.getElementById('shutterReportError');
        const tableBody = document.getElementById('shutterReportTableBody');
        errorEl.textContent = 'Loading...'; tableBody.innerHTML = '';
        const response = await fetch(`/shutter_report/${activeReportChannel}?start_date=${startDate}&end_date=${endDate}`);
        const data = await response.json();
        errorEl.textContent = data.error || '';
        if(data.report_data) data.report_data.forEach(row => {
            const openCell = row.first_open_video_url ? `<a href="#" onclick="event.preventDefault(); openShutterVideoModal('${row.first_open_video_url}', 'First Open on ${row.date}')" style="color: var(--accent-hover);">${row.first_open_time}</a>` : row.first_open_time;
            const closeCell = row.first_close_video_url ? `<a href="#" onclick="event.preventDefault(); openShutterVideoModal('${row.first_close_video_url}', 'First Close on ${row.date}')" style="color: var(--accent-hover);">${row.first_close_time}</a>` : row.first_close_time;
            tableBody.innerHTML += `<tr><td>${row.date}</td><td>${openCell}</td><td>${closeCell}</td></tr>`;
        });
    }
    async function fetchSecurityViolations(channelId) {
        const tbody = document.getElementById(`security-tbody-${channelId}`);
        if (!tbody) return;
        const response = await fetch(`/reports/security/${channelId}`);
        const violations = await response.json();
        tbody.innerHTML = violations.length === 0 ? '<tr><td colspan="3">No violations recorded.</td></tr>' : '';
        violations.forEach(v => {
            tbody.innerHTML += `<tr><td>${v.timestamp}</td><td>${v.message}</td><td>${v.details}</td></tr>`;
        });
    }

    // --- Smart Feed Loading Functions ---
    function createStreamElement(appName, channelId, channelName) {
        // Only People Counter shows feed by default
        const showFeedByDefault = appName === 'PeopleCounter';
        
        if (showFeedByDefault) {
            // Traditional stream for People Counter
            return `
                <div class="stream-box">
                    <div class="stream-header">${channelName}</div>
                    <img src="/video_feed/${appName}/${channelId}" 
                         alt="${channelName}" 
                         loading="lazy"
                         onerror="this.src='/static/placeholder.jpg'">
                    <div class="stream-footer" id="${appName}-count-${channelId}">
                        In: <span id="in-count-${channelId}">0</span> | 
                        Out: <span id="out-count-${channelId}">0</span>
                    </div>
                </div>
            `;
        } else {
            // Lazy-loaded stream for other apps
            return `
                <div class="stream-box" id="stream-container-${appName}-${channelId}">
                    <div class="stream-header">${channelName}</div>
                    <div class="feed-placeholder" 
                         id="placeholder-${appName}-${channelId}"
                         style="width: 100%; aspect-ratio: 16/9; background: #1a1f2e; 
                                display: flex; flex-direction: column; 
                                align-items: center; justify-content: center; 
                                color: #8B949E;">
                        <svg style="width: 48px; height: 48px; margin-bottom: 12px;" 
                             fill="currentColor" viewBox="0 0 20 20">
                            <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z"/>
                        </svg>
                        <p style="margin: 0 0 12px 0; font-size: 0.9em;">Feed hidden to improve performance</p>
                        <button class="btn btn-primary" 
                                onclick="loadFeed('${appName}', '${channelId}', '${channelName}')">
                            Show Feed
                        </button>
                    </div>
                    <div class="stream-footer" id="${appName}-status-${channelId}">
                        <!-- App-specific status -->
                    </div>
                </div>
            `;
        }
    }

    function loadFeed(appName, channelId, channelName) {
        const placeholder = document.getElementById(`placeholder-${appName}-${channelId}`);
        const container = document.getElementById(`stream-container-${appName}-${channelId}`);
        
        if (!placeholder || !container) return;
        
        // Show loading state
        placeholder.innerHTML = `
            <svg class="spinner" style="width: 48px; height: 48px; animation: spin 1s linear infinite;" 
                 fill="none" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" opacity="0.25"/>
                <path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" opacity="0.75"/>
            </svg>
            <p style="margin-top: 12px;">Loading feed...</p>
        `;
        
        // Create video feed
        const img = document.createElement('img');
        img.src = `/video_feed/${appName}/${channelId}`;
        img.alt = channelName;
        img.style.width = '100%';
        img.style.display = 'block';
        img.onerror = function() {
            placeholder.innerHTML = `
                <p style="color: #ef4444;">Failed to load feed</p>
                <button class="btn" onclick="loadFeed('${appName}', '${channelId}', '${channelName}')">
                    Retry
                </button>
            `;
        };
        img.onload = function() {
            placeholder.replaceWith(img);
        };
    }

    // Add CSS for spinner animation
    const style = document.createElement('style');
    style.textContent = `
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .feed-placeholder {
            transition: all 0.3s ease;
        }
        .feed-placeholder:hover {
            background: #242a38;
        }
    `;
    document.head.appendChild(style);

    // --- Dashboard Generation ---
    function generateDashboard() {
        const savedOrder = JSON.parse(localStorage.getItem('dashboardLayout'));
        const sortedAppNames = savedOrder || Object.keys(appConfigs).sort();

        sortedAppNames.forEach(appName => {
            if (!appConfigs[appName]) return;
            const config = appConfigs[appName];
            if (!config.channels || config.channels.length === 0) return;
            
            const section = document.createElement('div');
            section.className = 'app-section';
            section.dataset.appName = appName;
            
            let contentHTML = '';
            
            if (appName === 'PeopleCounter') {
                const channel = config.channels[0]; const today = new Date().toISOString().split('T')[0];
                contentHTML = `<div class="layout-grid">${createStreamElement('PeopleCounter', channel.id, channel.name)}<div class="report-section"><h3>Daily Footfall</h3><input type="date" value="${today}" onchange="fetchPCReport('${channel.id}', this.value)"><table><thead><tr><th>Hour</th><th>In</th><th>Out</th></tr></thead><tbody id="pc-report-table-${channel.id}"></tbody></table><button class="btn btn-primary" style="width: 100%; margin-top: 15px;" onclick="openReportModal('${channel.id}', '${channel.name}')">Generate Report</button></div></div>`;
                setTimeout(() => fetchPCReport(channel.id, today), 100);
            } else if (appName === 'ShutterMonitor') {
                const channel = config.channels[0];
                contentHTML = `<div class="summary-cards" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));">
                    <div class="summary-card"><h4>Current Status</h4><p id="shutter-status-${channel.id}">--</p><small id="shutter-status-time-${channel.id}">...</small></div>
                    <div class="summary-card"><h4>First Opening</h4><p id="shutter-first-open-${channel.id}">--</p></div>
                    <div class="summary-card"><h4>First Closing</h4><p id="shutter-first-close-${channel.id}">--</p></div>
                    <div class="summary-card"><h4>Total Open Time</h4><p id="shutter-total-open-${channel.id}">--</p></div>
                </div>
                <button class="btn btn-primary" style="width: 100%; margin-top: 20px;" onclick="openShutterReportModal('${channel.id}', '${channel.name}')">Generate Historical Report</button>`;
            } else if (appName === 'Security') {
                const channel = config.channels[0];
                contentHTML = `<div class="layout-grid">${createStreamElement('Security', channel.id, channel.name + ' - Live')}<div class="report-section"><h3>Recent Violations</h3><table id="security-table-${channel.id}"><thead><tr><th>Timestamp</th><th>Violation</th><th>Details</th></tr></thead><tbody id="security-tbody-${channel.id}"></tbody></table></div></div>`;
                setTimeout(() => fetchSecurityViolations(channel.id), 500);
            } else if (appName === 'OccupancyMonitor') {
                const tabsHTML = config.channels.map((channel, i) => 
                    `<button class="tab-button ${i === 0 ? 'active' : ''}" onclick="openTab(event, '${appName}')">${channel.name}</button>`
                ).join('');
                
                const contentDivs = config.channels.map((channel, i) => `
                    <div id="content-${appName}-${channel.id}" class="tab-content ${i === 0 ? 'active' : ''}">
                        <div id="occupancy-alert-${channel.id}" style="display: none; background-color: #dc2626; color: white; padding: 15px; border-radius: 6px; margin-bottom: 20px; font-weight: 600;">
                            <p id="alert-message-${channel.id}" style="margin: 0;"></p>
                        </div>
                        
                        <div class="layout-grid">
                            <div class="stream-box">
                                <div class="stream-header">${channel.name} - Live Feed</div>
                                <div class="feed-placeholder" 
                                     id="placeholder-OccupancyMonitor-${channel.id}"
                                     style="width: 100%; aspect-ratio: 16/9; background: #1a1f2e; 
                                            display: flex; flex-direction: column; 
                                            align-items: center; justify-content: center; 
                                            color: #8B949E;">
                                    <svg style="width: 48px; height: 48px; margin-bottom: 12px;" 
                                         fill="currentColor" viewBox="0 0 20 20">
                                        <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z"/>
                                    </svg>
                                    <p style="margin: 0 0 12px 0; font-size: 0.9em;">Feed hidden to improve performance</p>
                                    <button class="btn btn-primary" 
                                            onclick="loadFeed('OccupancyMonitor', '${channel.id}', '${channel.name} - Live Feed')">
                                        Show Feed
                                    </button>
                                </div>
                                <div class="stream-footer">
                                    Live: <span id="occupancy-live-${channel.id}" style="color: #10b981; font-weight: 700;">0</span> | 
                                    Required: <span id="occupancy-required-${channel.id}" style="color: #f59e0b; font-weight: 700;">N/A</span>
                                </div>
                            </div>
                            
                            <div class="report-section">
                                <h3>Schedule Management</h3>
                                
                                <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-primary); border-radius: 6px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">📊 Upload Schedule (.xlsx or .csv):</label>
                                    <input type="file" id="schedule-file-${channel.id}" accept=".xlsx,.csv" style="width: 100%; padding: 10px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary);">
                                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;" onclick="uploadOccupancySchedule('${channel.id}')">Upload Schedule</button>
                                    <small id="schedule-status-${channel.id}" style="display: block; margin-top: 8px; color: var(--text-secondary);">No schedule loaded</small>
                                </div>
                                
                                <div class="summary-cards" style="grid-template-columns: 1fr 1fr;">
                                    <div class="summary-card">
                                        <h4>Current Time Slot</h4>
                                        <p id="current-slot-${channel.id}" style="font-size: 1.1em;">--</p>
                                    </div>
                                    <div class="summary-card">
                                        <h4>Status</h4>
                                        <p id="status-${channel.id}" style="font-size: 1.1em;">--</p>
                                    </div>
                                </div>
                                
                                <div style="margin-top: 20px;">
                                    <h3>Occupancy Reports</h3>
                                    <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                                        <button class="btn" onclick="generateOccupancyReport('${channel.id}', 'today')">Today</button>
                                        <button class="btn" onclick="generateOccupancyReport('${channel.id}', 'yesterday')">Yesterday</button>
                                        <button class="btn" onclick="generateOccupancyReport('${channel.id}', '7days')">Last 7 Days</button>
                                    </div>
                                    
                                    <div id="occupancy-summary-${channel.id}" style="display: none;">
                                        <div class="summary-cards" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
                                            <div class="summary-card">
                                                <h4>Total Records</h4>
                                                <p id="summary-total-${channel.id}">0</p>
                                            </div>
                                            <div class="summary-card">
                                                <h4>Alerts</h4>
                                                <p id="summary-alerts-${channel.id}" style="color: #ef4444;">0</p>
                                            </div>
                                            <div class="summary-card">
                                                <h4>Compliance Rate</h4>
                                                <p id="summary-compliance-${channel.id}" style="color: #10b981;">0%</p>
                                            </div>
                                            <div class="summary-card">
                                                <h4>Avg Live Count</h4>
                                                <p id="summary-avg-live-${channel.id}">0</p>
                                            </div>
                                        </div>
                                        
                                        <div style="margin-top: 20px;">
                                            <canvas id="occupancy-chart-${channel.id}"></canvas>
                                        </div>
                                    </div>
                                    
                                    <div id="occupancy-error-${channel.id}" style="color: #ef4444; margin-top: 10px;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');
                
                contentHTML = `<div class="tab-nav">${tabsHTML}</div>${contentDivs}`;
            } else {
                const videoFeedApp = (['Shoplifting', 'QPOS', 'Generic'].includes(appName)) ? 'Detection' : appName;
                let tabsHTML = ''; let contentDivs = '';
                config.channels.forEach((channel, i) => {
                    const active = i === 0 ? 'active' : '';
                    tabsHTML += `<button class="tab-button ${active}" onclick="openTab(event, '${appName}')">${channel.name}</button>`;
                    contentDivs += `<div id="content-${appName}-${channel.id}" class="tab-content ${active}">
                        <div class="layout-grid">
                            <div class="stream-box" id="stream-box-${appName}-${channel.id}">
                                <div class="stream-header">${channel.name} - Live</div>
                                <div class="feed-placeholder" 
                                     id="placeholder-${appName}-${channel.id}"
                                     style="width: 100%; aspect-ratio: 16/9; background: #1a1f2e; 
                                            display: flex; flex-direction: column; 
                                            align-items: center; justify-content: center; 
                                            color: #8B949E;">
                                    <svg style="width: 48px; height: 48px; margin-bottom: 12px;" 
                                         fill="currentColor" viewBox="0 0 20 20">
                                        <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z"/>
                                    </svg>
                                    <p style="margin: 0 0 12px 0; font-size: 0.9em;">Feed hidden to improve performance</p>
                                    <button class="btn btn-primary" 
                                            onclick="loadFeed('${videoFeedApp}', '${channel.id}', '${channel.name} - Live')">
                                        Show Feed
                                    </button>
                                </div>
                                
                                ${appName === 'QueueMonitor' ? `
                                    <canvas class="roi-canvas" style="display:none;" 
                                        onclick="handleCanvasClick(event, '${appName}', '${channel.id}')"
                                        onmousedown="handleCanvasMouseDown(event, '${appName}', '${channel.id}')"
                                        onmousemove="handleCanvasMouseMove(event, '${appName}', '${channel.id}')"
                                        onmouseup="handleCanvasMouseUp(event, '${appName}', '${channel.id}')"></canvas>
                                ` : ''}
                                
                                ${appName === 'PeopleCounter' ? `
                                    <canvas class="line-canvas" style="display:none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;" 
                                        onmousedown="handleLineCanvasMouseDown(event, '${appName}', '${channel.id}')"
                                        onmousemove="handleLineCanvasMouseMove(event, '${appName}', '${channel.id}')"
                                        onmouseup="handleLineCanvasMouseUp(event, '${appName}', '${channel.id}')"></canvas>
                                ` : ''}
                                
                                ${appName === 'QueueMonitor' ? `<div class="stream-footer">Queue: <span id="queue-count-${channel.id}">...</span></div>` : ''}
                                ${appName === 'PeopleCounter' ? `<div class="stream-footer">IN: <span id="in-count-${channel.id}">...</span> | OUT: <span id="out-count-${channel.id}">...</span></div>` : ''}
                            </div>
                            <div class="report-section">
                                <h3>Detection History</h3>
                                <div class="filter-controls">
                                    <input type="date" id="start-date-${appName}-${channel.id}">
                                    <input type="date" id="end-date-${appName}-${channel.id}">
                                    <button class="btn" onclick="applyDateFilter('${appName}', '${channel.id}')">Filter</button>
                                    
                                    ${appName === 'QueueMonitor' ? `
                                        <button class="btn" style="margin-left: auto;" onclick="startRoiEdit('${appName}', '${channel.id}')">Edit ROI</button>
                                    ` : ''}
                                    
                                    ${appName === 'PeopleCounter' ? `
                                        <button class="btn" style="margin-left: auto;" onclick="startLineEdit('${appName}', '${channel.id}')">Edit Counting Line</button>
                                    ` : ''}
                                </div>
                                
                                ${appName === 'QueueMonitor' ? `
                                    <div class="roi-controls">
                                        <span id="roi-mode-indicator-${channel.id}" class="roi-mode-indicator roi-mode-main">Drawing: Queue Area (Yellow)</span>
                                        <div class="btn-group">
                                            <button class="btn" onclick="switchRoiMode('${channel.id}', 'main')">Draw Queue</button>
                                            <button class="btn" onclick="switchRoiMode('${channel.id}', 'secondary')">Draw Counter</button>
                                        </div>
                                        <button class="btn" onclick="resetRoi('${appName}', '${channel.id}')">Reset Current</button>
                                        <button class="btn" onclick="clearAllRoi('${appName}', '${channel.id}')">Clear All</button>
                                        <button class="btn" onclick="cancelRoiEdit('${appName}', '${channel.id}')">Cancel</button>
                                        <button class="btn btn-primary" onclick="saveRoi('${appName}', '${channel.id}')">Save ROI</button>
                                    </div>
                                ` : ''}
                                
                                ${appName === 'PeopleCounter' ? `
                                    <div class="line-editor-controls">
                                        <span style="font-weight: 600;">Line Orientation:</span>
                                        <div class="btn-group">
                                            <button class="btn" onclick="setLineOrientation('${channel.id}', 'vertical')">Vertical</button>
                                            <button class="btn" onclick="setLineOrientation('${channel.id}', 'horizontal')">Horizontal</button>
                                            <button class="btn" onclick="setLineOrientation('${channel.id}', 'angle')">Free Angle</button>
                                        </div>
                                        <span style="font-size: 0.85em; color: var(--text-secondary);">Drag endpoints or line to adjust</span>
                                        <button class="btn" onclick="cancelLineEdit('${appName}', '${channel.id}')">Cancel</button>
                                        <button class="btn btn-primary" onclick="saveLinePosition('${appName}', '${channel.id}')">Save Line</button>
                                    </div>
                                ` : ''}
                                
                                <div class="history-grid" id="grid-${appName}-${channel.id}"></div>
                                <div class="pagination" id="pagination-${appName}-${channel.id}"></div>
                            </div>
                        </div>
                    </div>`;
                    if (i === 0) setTimeout(() => fetchHistory(appName, 1, channel.id), 200);
                });
                contentHTML = `<div class="tab-nav">${tabsHTML}</div>${contentDivs}`;
            }
            const onlineStatus = `<span class="status"><span class="online-dot"></span>${config.online_count} / ${config.channels.length} Online</span>`;
            section.innerHTML = `<div class="app-header"><h2>${appName.replace(/([A-Z])/g, ' $1').trim()}</h2> ${onlineStatus}</div><div class="app-content">${contentHTML}</div>`;
            dashboardContainer.appendChild(section);
        });
        
        new Sortable(dashboardContainer, { animation: 150, handle: '.app-header', onEnd: (e) => {
            const order = Array.from(dashboardContainer.children).map(el => el.dataset.appName);
            localStorage.setItem('dashboardLayout', JSON.stringify(order));
        }});
    }

    function openTab(evt, appName) {
        const parent = evt.target.closest('.app-content');
        parent.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        parent.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));
        const channelId = parent.querySelectorAll('.tab-content')[Array.from(evt.target.parentNode.children).indexOf(evt.target)].id.split('-').pop();
        document.getElementById(`content-${appName}-${channelId}`).classList.add('active');
        evt.target.classList.add('active');
        fetchHistory(appName, 1, channelId);
    }
    
    function formatDuration(seconds) {
        const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60);
        return `${h}h ${m}m`;
    }

    // --- Socket.IO Connection Handlers ---
    socket.on('connect', () => {
        console.log('✅ Socket.IO connected successfully');
    });
    
    socket.on('disconnect', () => {
        console.warn('⚠️ Socket.IO disconnected');
    });
    
    socket.on('connect_error', (error) => {
        console.error('❌ Socket.IO connection error:', error);
    });

    // --- Socket.IO Listeners ---
    socket.on('count_update', data => {
        const inEl = document.getElementById(`in-count-${data.channel_id}`);
        const outEl = document.getElementById(`out-count-${data.channel_id}`);
        if (inEl) inEl.textContent = data.in_count;
        if (outEl) outEl.textContent = data.out_count;
    });
    
    socket.on('queue_update', data => {
        const el = document.getElementById(`queue-count-${data.channel_id}`);
        if(el) el.textContent = data.count;
    });
    
    socket.on('shutter_update', data => {
        const statusEl = document.getElementById(`shutter-status-${data.channel_id}`);
        const timeEl = document.getElementById(`shutter-status-time-${data.channel_id}`);
        const openEl = document.getElementById(`shutter-first-open-${data.channel_id}`);
        const closeEl = document.getElementById(`shutter-first-close-${data.channel_id}`);
        const totalEl = document.getElementById(`shutter-total-open-${data.channel_id}`);
        
        if (statusEl) statusEl.textContent = data.last_status.toUpperCase();
        if (timeEl) timeEl.textContent = `Since ${new Date(data.last_status_time).toLocaleTimeString()}`;
        if (openEl) openEl.textContent = data.first_open_time ? new Date(data.first_open_time).toLocaleTimeString() : 'N/A';
        if (closeEl) closeEl.textContent = data.first_close_time ? new Date(data.first_close_time).toLocaleTimeString() : 'N/A';
        if (totalEl) totalEl.textContent = formatDuration(data.total_open_duration_seconds);
    });
    
    socket.on('new_detection', data => {
        const activeTab = document.querySelector(`#content-${data.app_name}-${data.channel_id}.active`);
        if (activeTab) fetchHistory(data.app_name, 1, data.channel_id);
    });
    
    socket.on('security_violation', data => {
        const tbody = document.getElementById(`security-tbody-${data.channel_id}`);
        if (tbody) {
            tbody.insertAdjacentHTML('afterbegin', `<tr><td>${data.timestamp}</td><td>${data.message}</td><td>${data.details}</td></tr>`);
            if (tbody.rows.length > 15) tbody.deleteRow(-1);
        }
    });

    // --- Occupancy Monitor Functions ---
    let occupancyCharts = {};

    async function uploadOccupancySchedule(channelId) {
        const fileInput = document.getElementById(`schedule-file-${channelId}`);
        const statusEl = document.getElementById(`schedule-status-${channelId}`);
        
        if (!fileInput.files || fileInput.files.length === 0) {
            statusEl.textContent = 'Please select a file first';
            statusEl.style.color = '#ef4444';
            return;
        }
        
        const formData = new FormData();
        formData.append('file', fileInput.files[0]);
        
        statusEl.textContent = 'Uploading...';
        statusEl.style.color = '#f59e0b';
        
        try {
            const response = await fetch(`/api/upload_occupancy_schedule/${channelId}`, {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                statusEl.textContent = result.message;
                statusEl.style.color = '#10b981';
                fileInput.value = '';
            } else {
                statusEl.textContent = 'Error: ' + (result.error || 'Upload failed');
                statusEl.style.color = '#ef4444';
            }
        } catch (error) {
            statusEl.textContent = 'Error: ' + error.message;
            statusEl.style.color = '#ef4444';
        }
    }

    async function generateOccupancyReport(channelId, period) {
        const errorEl = document.getElementById(`occupancy-error-${channelId}`);
        const summaryEl = document.getElementById(`occupancy-summary-${channelId}`);
        
        errorEl.textContent = 'Loading report...';
        summaryEl.style.display = 'none';
        
        try {
            const response = await fetch(`/occupancy_report/${channelId}?period=${period}`);
            const data = await response.json();
            
            if (data.error) {
                errorEl.textContent = data.error;
                return;
            }
            
            errorEl.textContent = '';
            summaryEl.style.display = 'block';
            
            // Update summary
            document.getElementById(`summary-total-${channelId}`).textContent = data.summary.total_records;
            document.getElementById(`summary-alerts-${channelId}`).textContent = data.summary.alerts_count;
            document.getElementById(`summary-compliance-${channelId}`).textContent = data.summary.compliance_rate + '%';
            document.getElementById(`summary-avg-live-${channelId}`).textContent = data.summary.avg_live_count;
            
            // Render chart
            renderOccupancyChart(channelId, data);
            
        } catch (error) {
            errorEl.textContent = 'Error loading report: ' + error.message;
        }
    }

    function renderOccupancyChart(channelId, data) {
        const canvasId = `occupancy-chart-${channelId}`;
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Destroy existing chart
        if (occupancyCharts[channelId]) {
            occupancyCharts[channelId].destroy();
        }
        
        // Create new chart
        occupancyCharts[channelId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.labels,
                datasets: [
                    {
                        label: 'Live Count',
                        data: data.live_counts,
                        borderColor: 'rgba(16, 185, 129, 1)',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.3,
                        fill: true
                    },
                    {
                        label: 'Required Count',
                        data: data.required_counts,
                        borderColor: 'rgba(245, 158, 11, 1)',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        tension: 0.3,
                        fill: true,
                        borderDash: [5, 5]
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: 'rgba(201, 209, 217, 0.1)' },
                        ticks: { color: 'var(--text-secondary)' }
                    },
                    x: {
                        grid: { color: 'rgba(201, 209, 217, 0.1)' },
                        ticks: { 
                            color: 'var(--text-secondary)',
                            maxRotation: 45,
                            minRotation: 45
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: 'var(--text-primary)' }
                    },
                    tooltip: {
                        callbacks: {
                            afterLabel: function(context) {
                                const index = context.dataIndex;
                                const status = data.statuses[index];
                                if (status === 'BELOW_REQUIREMENT') {
                                    return '⚠️ Below Requirement';
                                } else if (status === 'OK') {
                                    return '✅ OK';
                                }
                                return '';
                            }
                        }
                    }
                }
            }
        });
    }

    // Socket.IO listener for occupancy updates
    socket.on('occupancy_update', data => {
        const liveEl = document.getElementById(`occupancy-live-${data.channel_id}`);
        const requiredEl = document.getElementById(`occupancy-required-${data.channel_id}`);
        const slotEl = document.getElementById(`current-slot-${data.channel_id}`);
        const statusEl = document.getElementById(`status-${data.channel_id}`);
        const alertBanner = document.getElementById(`occupancy-alert-${data.channel_id}`);
        const alertMsg = document.getElementById(`alert-message-${data.channel_id}`);
        
        if (liveEl) liveEl.textContent = data.live_count;
        if (requiredEl) requiredEl.textContent = data.required_count || 'N/A';
        if (slotEl) slotEl.textContent = data.time_slot;
        
        if (statusEl) {
            if (data.status === 'BELOW_REQUIREMENT') {
                statusEl.textContent = '⚠️ Below Requirement';
                statusEl.style.color = '#ef4444';
            } else if (data.status === 'OK') {
                statusEl.textContent = '✅ OK';
                statusEl.style.color = '#10b981';
            } else {
                statusEl.textContent = '—';
                statusEl.style.color = 'var(--text-secondary)';
            }
        }
        
        // Show/hide alert banner
        if (alertBanner && alertMsg) {
            if (data.status === 'BELOW_REQUIREMENT') {
                alertBanner.style.display = 'block';
                alertMsg.textContent = `⚠️ ALERT: People count below requirement! (Required: ${data.required_count}, Detected: ${data.live_count})`;
            } else {
                alertBanner.style.display = 'none';
            }
        }
    });

    generateDashboard();
</script>
</body>
</html>

